"""
AI对话知识库与匹配引擎
============================================================
思路说明：
将AI对话的核心逻辑从前端移到后端。

为什么放后端：
1. 知识库是数据资产，应该由服务端管理，方便扩展和更新
2. 匹配算法可以做得更复杂（TF-IDF、语义匹配等），不受前端性能限制
3. 后续接入真正的AI服务（通义千问/OpenAI）时，API Key必须放后端，不能暴露给前端
4. 对话历史需要持久化到数据库，后端直接操作更方便

匹配算法：
当前使用关键词匹配（简单可靠），后续可升级为：
- TF-IDF 向量相似度
- 接入大语言模型API
============================================================
"""


# 快速排序知识库
# 每个条目包含：关键词列表、所属知识点主题、回答内容
QA_KNOWLEDGE_BASE = [
    {
        'keywords': ['时间复杂度', '复杂度', '效率', '性能', '快不快'],
        'topic': '复杂度分析',
        'answer': (
            '快速排序的平均时间复杂度是 O(n log n)，这是比较排序算法的理论最优。'
            '最坏情况（数组已有序且每次选第一个/最后一个为基准）时间复杂度退化为 O(n²)。'
            '空间复杂度为 O(log n)，主要来自递归调用栈。'
            '在实际应用中，快速排序通常是最快的通用排序算法之一。'
        )
    },
    {
        'keywords': ['基准', 'pivot', '选择基准', '怎么选'],
        'topic': '基准选择',
        'answer': (
            '基准(Pivot)的选择直接影响快速排序的效率。常见策略有：\n'
            '1. 选最后一个元素（本演示采用的方式，实现简单）\n'
            '2. 选第一个元素（同样简单，但对有序数组表现差）\n'
            '3. 随机选择（避免最坏情况，实际中常用）\n'
            '4. 三数取中法（取首、中、尾三个元素的中位数，效果好）\n\n'
            '好的基准应该尽量将数组等分为两半，这样递归树最平衡，效率最高。'
        )
    },
    {
        'keywords': ['分区', 'partition', '怎么分', '划分'],
        'topic': '分区操作',
        'answer': (
            '分区(Partition)是快速排序的核心操作。本演示使用 Lomuto 分区方案：\n'
            '1. 选最后一个元素为基准 pivot\n'
            '2. 维护指针 i，指向"小于等于pivot区域"的末尾\n'
            '3. 用指针 j 从左到右扫描数组\n'
            '4. 如果 arr[j] <= pivot，就把 i 右移一位，然后交换 arr[i] 和 arr[j]\n'
            '5. 扫描完成后，把 pivot 放到 i+1 的位置\n\n'
            '这样 pivot 左边都 <= pivot，右边都 > pivot。'
        )
    },
    {
        'keywords': ['递归', '为什么递归', '递归调用', '怎么递归'],
        'topic': '递归调用',
        'answer': (
            '快速排序使用递归实现分治策略：\n'
            '1. 对数组进行一次分区，基准元素就位\n'
            '2. 对基准左边的子数组递归调用快速排序\n'
            '3. 对基准右边的子数组递归调用快速排序\n\n'
            '递归终止条件：当子数组长度 <= 1 时（即 low >= high），不需要再排序。\n\n'
            '递归深度最好情况是 O(log n)（每次等分），最坏是 O(n)（每次只减少一个元素）。'
        )
    },
    {
        'keywords': ['分治', '思想', '原理', '为什么快'],
        'topic': '分治思想',
        'answer': (
            '快速排序体现了经典的分治(Divide and Conquer)思想：\n'
            '1. 分(Divide)：通过分区操作，将问题分成两个更小的子问题\n'
            '2. 治(Conquer)：递归地对两个子数组排序\n'
            '3. 合(Combine)：由于是原地排序，分区完成后数组自然有序，无需额外合并\n\n'
            '分治的关键优势：将 O(n²) 的问题分解为两个 O(n/2) 的子问题，总工作量降为 O(n log n)。'
        )
    },
    {
        'keywords': ['稳定', '稳定性', '稳定排序'],
        'topic': '复杂度分析',
        'answer': (
            '快速排序是不稳定的排序算法。所谓"不稳定"是指：如果数组中有两个相等的元素，'
            '排序后它们的相对顺序可能改变。\n\n'
            '例如：[3a, 2, 3b, 1] 排序后可能变成 [1, 2, 3b, 3a]，3a和3b的顺序反了。\n\n'
            '如果需要稳定排序，可以考虑归并排序(Merge Sort)。'
        )
    },
    {
        'keywords': ['冒泡', '比较', '区别', '不同', '对比'],
        'topic': '复杂度分析',
        'answer': (
            '快速排序 vs 冒泡排序：\n'
            '- 时间复杂度：快排平均 O(n log n)，冒泡 O(n²)\n'
            '- 空间复杂度：快排 O(log n)，冒泡 O(1)\n'
            '- 稳定性：快排不稳定，冒泡稳定\n'
            '- 实际性能：快排远快于冒泡，是实际应用中最常用的排序算法之一\n'
            '- 思想：快排用分治，冒泡用相邻比较交换\n\n'
            '对于大数据量，快速排序的优势非常明显。'
        )
    },
    {
        'keywords': ['交换', 'swap', '怎么交换'],
        'topic': '分区操作',
        'answer': (
            '在本演示的代码中，交换使用了 JavaScript 的解构赋值语法：\n'
            '[arr[i], arr[j]] = [arr[j], arr[i]]\n\n'
            '这等价于：\nlet temp = arr[i];\narr[i] = arr[j];\narr[j] = temp;\n\n'
            '交换发生在两个地方：\n'
            '1. 分区过程中，将小于基准的元素交换到左边（第17行）\n'
            '2. 分区结束后，将基准放到正确位置（第20行）'
        )
    },
    {
        'keywords': ['最坏', '退化', 'worst', '有序'],
        'topic': '复杂度分析',
        'answer': (
            '快速排序的最坏情况发生在每次分区都极度不平衡时：\n'
            '- 数组已经有序（升序或降序），且每次选第一个或最后一个为基准\n'
            '- 此时每次分区只能减少一个元素，递归深度达到 n\n'
            '- 时间复杂度退化为 O(n²)\n\n'
            '避免最坏情况的方法：\n'
            '1. 随机选择基准\n2. 三数取中法\n3. 对小数组切换到插入排序'
        )
    },
]


def match_answer(question):
    """
    关键词匹配回答

    参数:
        question: 用户输入的问题字符串
    返回:
        (answer, topic) 元组，answer是回答文本，topic是匹配到的知识点主题

    匹配原理：
    遍历知识库中每个条目的关键词列表，统计用户问题中包含了多少个关键词，
    选择匹配数最多的条目作为回答。如果没有任何匹配，返回通用引导回答。
    """
    q = question.lower()
    best_match = None
    best_score = 0

    for qa in QA_KNOWLEDGE_BASE:
        score = sum(1 for kw in qa['keywords'] if kw in q)
        if score > best_score:
            best_score = score
            best_match = qa

    if best_match and best_score > 0:
        return best_match['answer'], best_match['topic']

    # 没有匹配到任何关键词，返回引导性回答
    return (
        '这是一个好问题！关于快速排序，你可以尝试问我以下方面的问题：\n'
        '- 时间复杂度和空间复杂度\n'
        '- 基准(Pivot)的选择策略\n'
        '- 分区(Partition)操作的原理\n'
        '- 递归调用的过程\n'
        '- 与冒泡排序的区别\n'
        '- 最坏情况及优化方法\n'
        '- 稳定性问题'
    ), ''
